use lapin::{
    message::{DeliveryResult, Delivery},
    options::{
        BasicAckOptions, BasicConsumeOptions, BasicPublishOptions, QueueBindOptions,
        QueueDeclareOptions,
    },
    types::FieldTable,
    BasicProperties, Connection, ConnectionProperties,
};
use serde::{Deserialize, Serialize};
use std::env;
use uuid::Uuid;
use std::{thread, time};

use futures_lite::stream::StreamExt;
use lapin::{
    options::*, publisher_confirm::Confirmation, types::FieldTable, BasicProperties, Connection,
    ConnectionProperties, Result,
};
use tracing::info;

#[derive(Debug, Serialize, Deserialize)]
struct Message {
    name: String,
    size: u32,
}

fn get_address() -> String {
    let user = env::var("RABBITMQ_USER").expect("RABBITMQ_USER not set");
    let password = env::var("RABBITMQ_PASSWORD").expect("RABBITMQ_PASSWORD not set");
    let host = env::var("RABBITMQ_HOST").expect("RABBITMQ_HOST not set");
    format!("amqp://{}:{}@{}:5672/%2f", user, password, host)
}

async fn get_connection() -> Result<lapin::Connection, lapin::Error> {
    let uri = get_address();
    let options = ConnectionProperties::default()
        // Use tokio executor and reactor.
        // At the moment the reactor is only available for unix.
        .with_executor(tokio_executor_trait::Tokio::current())
        .with_reactor(tokio_reactor_trait::Tokio);

    Connection::connect(&uri, options).await
}

#[tokio::main]
async fn aync_service(service_name: &str) {
    let connection = get_connection().await.unwrap();
    let channel = connection.create_channel().await.unwrap();
    let rpc_queue = format!("rpc-{}", service_name);
    let routing_key = format!("{}.*", service_name);
    let _queue = channel
        .queue_declare(
            &rpc_queue,
            QueueDeclareOptions::default(),
            FieldTable::default(),
        )
        .await
        .unwrap();
    let _incomming_queue = channel
        .queue_bind(
            &rpc_queue,
            "nameko-rpc",
            &routing_key,
            QueueBindOptions::default(),
            FieldTable::default(),
        )
        .await
        .unwrap();

    let consumer = channel
        .basic_consume(
            &rpc_queue,
            "tag_foo",
            BasicConsumeOptions::default(),
            FieldTable::default(),
        )
        .await
        .unwrap();

        let id = Uuid::new_v4();
    let rpc_queue_reply = format!("rpc.reply-{}-{}", service_name, &id);
    channel
        .queue_declare(
            &rpc_queue_reply,
            QueueDeclareOptions::default(),
            FieldTable::default(),
        )
        .await
        .unwrap();
    channel
        .queue_bind(
            &rpc_queue_reply,
            "nameko-rpc",
            &format!("{}", &id),
            QueueBindOptions::default(),
            FieldTable::default(),
        )
        .await
        .unwrap();
    consumer.set_delegate(move |delivery: DeliveryResult| async move {
        let delivery = match delivery {
            // Carries the delivery alongside its channel
            Ok(Some(delivery)) => delivery,
            // The consumer got canceled
            Ok(None) => return,
            // Carries the error and is always followed by Ok(None)
            Err(error) => {
                dbg!("Failed to consume queue message {}", error);
                return;
            }
        };
        println!("Received message: {:#?}", &delivery);
        delivery
            .ack(BasicAckOptions::default())
            .await
            .expect("Failed to ack send_webhook_event message");
        //let payload: Message = serde_json::from_slice(&delivery.data).unwrap();
        //println!("Received message: {:#?}", payload);
    });

    thread::sleep(ten_millis);
    channel
        .basic_publish(
            "nameko-rpc",
            &format!("{}", id),
            BasicPublishOptions::default(),
            b"Hello world!",
            BasicProperties::default(),
        )
        .await
        .unwrap()
        .await
        .unwrap();

    std::future::pending::<()>().await;
}


fn service(service_name: &str) {
    let rpc_queue = format!("rpc-{}", service_name);
    let routing_key = format!("{}.*", service_name);
    async_global_executor::block_on(async {
        let conn = Connection::connect(
            &get_address(),
            ConnectionProperties::default(),
        )
        .await?;

        info!("CONNECTED");

        let channel_a = conn.create_channel().await?;
        let channel_b = conn.create_channel().await?;

        let queue = channel_a
            .queue_declare(
                &rpc_queue,
                QueueDeclareOptions::default(),
                FieldTable::default(),
            )
            .await?;
        channel_a.queue_bind(
            &rpc_queue,
            "nameko-rpc",
            &routing_key,
            QueueBindOptions::default(),
            FieldTable::default(),
        )
        .await
        .unwrap();

        info!(?queue, "Declared queue");

        let mut consumer = channel_b
            .basic_consume(
                "hello",
                "my_consumer",
                BasicConsumeOptions::default(),
                FieldTable::default(),
            )
            .await?;
        async_global_executor::spawn(async move {
            info!("will consume");
            while let Some(delivery) = consumer.next().await {
                let delivery = delivery.expect("error in consumer");
                delivery
                    .ack(BasicAckOptions::default())
                    .await
                    .expect("ack");
            }
        }).detach();

        let payload = b"Hello world!";

        loop {
            let confirm = channel_a
                .basic_publish(
                    "",
                    "hello",
                    BasicPublishOptions::default(),
                    payload,
                    BasicProperties::default(),
                )
                .await?
                .await?;
            assert_eq!(confirm, Confirmation::NotRequested);
        }
    })
}
fn main() {
    service("video");
}
